package Assignment1;

import Assignment1.Part2ReportGeneration.Assignment1Part2;
import Assignment1.Part2ReportGeneration.ResponseSummary;
import Assignment1.model.RandomSkier;
import com.opencsv.CSVWriter;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.CountDownLatch;

public class Assignment1Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {

        //Part 1
        //This is the part 1 of Assignment 1, which will generate 100 threads that each of them will
        //do POST action 1000 times.
        long start_time = System.currentTimeMillis();
        long end_time;
        long total_time;
        double throughput;

        // print out start time.
        System.out.println("-------------------------");
        System.out.println("Part 1 result: ");
        System.out.println("Start Time: " + start_time);

        // define lift ride events variables.
        int LIFT_RIDE_EVENTS_AMOUNT = 200000;

        // this is the amount of initially existed threads count. In Assignment 1, there are 32 threads running.
        int INITIAL_THREADS_AMOUNT = 32;

        // another 168 threads will be created at the same time to do POST works.
        int MORE_THREADS_AMOUNT = 168;

        // this blocking queue saves all lift events generated by ThreadSkierGeneration.
        BlockingQueue<RandomSkier> queue = new ArrayBlockingQueue<>(LIFT_RIDE_EVENTS_AMOUNT);

        // this blocking queue saves all time consumption data.
        BlockingQueue<String[]> result_data = new ArrayBlockingQueue<>(LIFT_RIDE_EVENTS_AMOUNT);

        // this is the CountDownLatch that command the main function to run after all threads die,
        // it helps record end time and total time consumption.
        CountDownLatch countDownLatch = new CountDownLatch(INITIAL_THREADS_AMOUNT + MORE_THREADS_AMOUNT + 1);

        // thread that generate random skiers.
        ThreadSkierGeneration skier_generation = new ThreadSkierGeneration(
                queue,
                LIFT_RIDE_EVENTS_AMOUNT,
                countDownLatch
        );

        // thread that do post.
        ThreadDoPost skier_doPost = new ThreadDoPost(queue, result_data, countDownLatch);

        // begin both threads.
        int successful_thread_count = 0;
        int failed_thread_count = 0;
        new Thread(skier_generation).start();
        for (int i=0; i<INITIAL_THREADS_AMOUNT + MORE_THREADS_AMOUNT; i++) {

            try{
                new Thread(skier_doPost).start();
                successful_thread_count ++;
            }catch (Exception e) {
                failed_thread_count ++;
                System.out.println(e.getMessage());
            }
        }

        // command CountDownLatch to await until all threads die.
        try {
            countDownLatch.await();
            end_time = System.currentTimeMillis();
            System.out.println("End Time: " + end_time);
            total_time = end_time - start_time;
            throughput = (double) ((long)LIFT_RIDE_EVENTS_AMOUNT) / total_time;
            double throughput_in_seconds = throughput * 1000;
            System.out.println("Total Time consumed: " + total_time + "ms.");
            System.out.println("Successful Thread Count: " + successful_thread_count);
            System.out.println("Failed Thread Count: " + failed_thread_count);
            System.out.println("Throughput: " + throughput + " requests/ms");
            System.out.println("-------------------------");
        } catch (InterruptedException e) {
            System.out.println(e.getMessage());
        }

        //Part 2
        new Assignment1Part2(result_data);
    }

}
